# Arun Agarwal Assignment 1 Documentation
# Project 1: The /PROC File System

Below is my documentation for Assignment 1 of CIS 3207, the /PROC File System:

### Project Introduction:
The overarching goal of this project is to write a simplified version of the ps command in linux. This version of ps, called tups is executed from the command line. It reads a variety of information about one or more running programs (processes) on the computer, and then displays the informaiton. For example, if the user were to type into the terminal:
**./tups -p 1234 -s -U -c**
This will run the main file, which calls the parser file and option processor file to output the pid of the inputted pid, and the system state. The -U signals not to display the user time, and the -c signals to not output the command line path for that pid:
**PID: 1234     State: R**

A list of the usable flags/commands for my implementation of the ps command are written below:
|  &nbsp;&nbsp;     OPTION &nbsp;&nbsp;		| 	DESCRIPTION   |  
| ------------- | ------------------- |
| -p  \<pid\>| Displays process information only for the process whose number is pid. It does not matter if the specified process is owned by the current user. If this option is not present or a pid arg is not provided, then it displays information for all processes of the current user (and only of the current user).	|
| -s | Displays the single-character state information about the process. This information is found in the stat file in the process’s directory, by looking at the third (“state”) field. This can be 'R' or 'Z', for example.  |
| -U | If this option/flag is present, the terminal does not display the amount of user time consumed by this process. This information is found in the stat file in the process’s directory, by looking at the “utime” field. If this option is not present, then user time information is displayed.  |
| -S | Displays the amount of system time consumed so far by this process. This information is found in the stat file in the process’s directory, by looking at the “stime” field.  |
| -v | Displays the amount of virtual memory currently used (in pages) by this program. This information is found in the statm file in the process’s directory, by looking at the  first (“size”) field.  |
| -c | If this option/flag is present, we do not display the command-line that started this program. This information is found in the  cmdline file in the process’s directory. If this option is not present, then command line information is displayed.  |

This project can be used for multiple things. For example, if a person does not know how to access certain process information using the linux terminal, they can simply run this program to get valuable information such as the pid, state (whether it is running or not and other information), the user time, the system time, the command line that started the process, and the virtual memory that the process takes up. This project can also be used to easily and quickly see this information for all processes of the current user currently running on the OS in a neatly formatted way. The code can also be easily tweaked to see the information for all processes, not just the current user, providing further information. 

### Details of the /PROC Filesystem:
The /proc file system provides access to the state of each active process and thread in the system. The /proc file system cotnains a directory entry for each process running on the Linux system. The name of each directory in the filesystem is the process ID of the corresponding process. These directories appear and disappear dynamically as processes start and terminate on the system. Each  directory contains several entries providing access to information about the running process. From these process directories, the /proc file system gets its name.

These entries are subdirectories and the owner of each is determined by the user ID of the process. Access to the process state is provided by additional files contained within each subdirectory. Except where otherwise specified, the term /proc file is meant to refer to a non-directory file within the hierarchy rooted at /proc.  

/proc is known as a “pseudo-filesystem”, which means it is not a true filesystem that is consuming storage. The files and directories in /proc are entry points into kernel tables, such as the open file table or the process table. 

The directories in the /proc filesystem that are used for this project include:
| Directory		| 	Description   |  
| ------------- | ------------------- |
| /proc/PID/cmdline	| 	Command line arguments, which is used for the -c flag |  
| /proc/PID/stat	|	Process status, which is used for the -p, -s, -U, and -S flags | 
| /proc/PID/statm	|	Process memory status information, which is used for the -v flag| 
| /proc/PID/status	|	Process status in human readable form, which is used to access the user id| 

### Overview of Project Design:
Next, I will provide a high-level overview of my project design. The key to any good program, and the key to making implementation of the desired ps command simple, is having a clean, modular design. With such a design, the code will be simpler, smaller, and easier to debug. Thus, I have tried to create a clean and modular design to the best of my abilities.

While a simple program with few components, I tried to develop clean interfaces for each component. Firthermore, each component is kept in a separately compiled file, linked together at the final step using a MakeFile. This MakeFile controls the building (compiling and linking) of my code.

To begin, here are the main files in my project along with their description:
| Directory		| 	Description   |  
| ------------- | ------------------- |
| /Makefile | File to control the building (compiling and linking) of each component of this project |
| /src/main.cpp | File including main function, which allows the program to run and call other files/functions, as desired |
| /src/parser.cpp | File to parse the command line if a -p is provided, ideally with a pid, and print out the desired information |
| /src/parser.h | Header file for parser.cpp, holding function headers from this file to be used by other files in this project |
| /src/getProcessList.cpp | File to parse the command line if no -p is provided, thus printing out all pids of the current user based on the inputted flags. It will also print out a few things to the terminal for nice formatting |
| /src/getProcessList.h | Header file for getProcessList.cpp, holding function headers from this file to be used by other files in this project |
| /src/optionProcessor.cpp | File holding all of my Functions for dealing with the commands inputted and checking validity of various pieces of information|
| /src/optionProcessor.h | Header file for optionProcessor.c, holding function headers from this file to be used by other files in this project |

I will now provide a walkthrough of my design. First the main.cpp file contains only one function, the main function. This function is what starts the project implementation. It takes in argc, the number of arguments inputted into the terminal, and argv, an array of the arguments from the terminal. The main function will find if the user entered -p as an argument. If this is found, it will increment a variable foundP to 1, indicating the need to call the normal parser function. Otherwise, it did not find the -p flaf, and call the function to print all pid information for the current user based on inputted flags. Since these functions exist in another files, for clean and modular design, header files for their respective locations, parser.h and getProcessList.h, are included at the beginning of the file. 

Next, in the case that the -p command is found, the parser.cpp file's parser function is called. This takes input from the main function to parse the command line and output the desire flag information. It does this through using the reccomended getopt function. The file includes global variables to store information on whether the desired flags exist in the argv array (input into the terminal). After changing the true/false values for each of the flags, the function calls functions in the optionProcessor.cpp file to grab the desired information. Thus, a header file, optionProcessor.h, is included at the beginning of the file. After grabbing the desired information, the function prints to the terminal the desired information, based on the true/false values of the flags. This file also includes a function, isPid, to check if an inputted string is a Pid. 

Now, in the case that the -p command is not found, the getProcessList.cpp file's allParser function is called. This also takes input from the main function to parse the command line and output the desired flag information for all current user pids. It does through a similar way that the parser function in the parser.cpp file does, but it does not check for the -p flag. Also, this function does not call any functions inside of optionProcessor.cpp to gather desired information. Instead, it focuses on just setting the true/false values of the commands inputted. It will call a separate function, called findAllPID() to first check which PIDs to gather this information from. Thus, this function reads through the proc file system, file by file, checking to see if the file name is a pid, a number, and a pid of the current user. It checks if the pid is a number using the isDigit function. Also, it checks if the pid is a process of the current user using a function in theOptionProcessor.cpp file called isUserId(). Thus, this file also includes the header file optionProcessor.h. For each pid it finds that passes these checks, it calls another function in the getProcessList.cpp file, getAllPIDParser, to finally gather the desired information. Specifically, this function calls the functions in optionProcessor.cpp that will gather the desired information from the stat, status, and cmdline files of the proc/[pid] directory (similar to the parser.cpp file). These functions will be discussed next.

Finally, the optionProcessor.cpp file holds all of my functions for dealing with the commands inputted and checking validity of various pieces of information, as discussed earlier. The first function, validPID(), checks if an inputted PID exists in the proc filesystem. This is important for error checking when a pid is provided. Next, parseStat() is my main function for parsing the stat file. This function reads through the file for the given pid and stores the values into an array of strings, which is referenced in the file that calls this function. Next, the getVMem() function is my main function for parsing the statm file to get the virtual memory. It takes as input a string to hold the virtual memory amount found in the statm file and the pid for the process we want to get the virtual memory for. Moving on, the getCommandLine() function is my main function for parsing the cmdline file to get the command line. It creates an array in the exact same way as the parseStat() file, taking note of null characters that exist throughout the file. Finally, when printing all pids of the current user id to the terminal, we need to check if the pid from proc is a pid of the current user. Thus, the isUserId() function checks this, taking as input a given pid. It will return 0 if the pid belongs the current user and return 1 if it does not belong to the current user.

These files are compiled and linked together using the MakeFile, which allows the program to run as intended, with the desired information printed to the terminal.

### Description of Testing Methods Used:
There are various testing methods used throughout this project to make sure it works as intended. In general, I first tested the separate parts of my program, such as processing command line optins, listing all files in /proc, and reading and parsing the individual files in a process's /proc directory. I then started assembling the pieces into a whole program, testing the options one at a time. I learned how to use shell scripts so that I could set up sequences of command lines to run over and over again (mostly important for the MakeFile). 

I also followed some general coding standards for code readability, testing, and good error checking:
1. I checked all the return values of all systems and library calls.
2. I always indenting when statements were part of control-flow statements such as "if" or "while"
3. I made sure to include no consants in my code. If a constant were to be included in my code, I made sure to define it using a "const" declaration.
4. I used global variables only to hold the true/false information for the six flags. This needed to be done since these variables were accessed by multiple functions in each file.
5. In terms of commenting my code, I made sure each file had a comment block at the top with my name, date, and description of the file. Also, each function has a comment at the beginning summarizing what it does and how it does it. They also describe the input and output parameters. For my longer functions, I also made sure to include comments at reaosnable intervals so that the reader would understand what I was doing. 
6. I used a makefile for the compiling and linking of my program. I made sure to include a clean rule to remove all .o and executable files.
7. I made use of multiple of standard Linux Library functions.
8. I did not use any other person's code without proper citation.
9. I overall made sure to have a clean modular design. This kept my code simpler, smaller, and easier to debug. I developed clean interfaces for each component. 

I will now go into the specifics of how I tested the functions I created. I cannot provide screenshots, as reccomended, because the testing code has either been removed or commented out. I also do not know how to post screenshots into a README file. Thus, I will describe the testing methods used in detail. 

For the main file, I tested that the header files were working as intended by created sample functions in the corresponding files to see if the linking was happening between the files. To test the output of the terminal was as desired, I used various print statements for argc and argv in the main function. To get the logic correct for when to run each function in main, I simply went through a few trial and error scenarios. 

Next, for the parser file, I used multiple testing methods, some of which I kept in my code for showcasing. First, I noticed that not all given pids were actual pids. Thus, I made a function to test whether the inputted was in fact a pid. In the parser funciton, I included various print statements for each flag to make sure that the function was going through the flags in argv as desired. These print statements were later removed for code readability. All print statements for this function were also placed at the end for readability. I included two cases in the getopt function, ':' and '?' that are soley for different error checking cases. Also, I used my validPID() function various times to make sure the inputted PID actually exists in the /proc file system. There was also a for loop added to check for extra arguments inputted. Some perror() statements were kept in the code for cases of errors. I originally tried to use this same function for the case that no -p was included, but this kept leading to erros such as segmentation faults because of the way the code was setup--the fact that the optarg is expected to come after -p causes mistreatment of other flags to be seen as the pid optarg. Also, the parser function was setup to take in argv and argc, so in the case that I needed to print all pids, I would need to build an argv from scratch for every process of the current user. Thus, I instead decided to write a separate function for parsing for the all pid case in the getProcessList file, which also led to cleaner code.

Moving on, for the getProcessList file, I did not run into as many errors as this was created near the end of my work with this project, in which I was more comfortable with the various things I needed to use to get this functionality. Nonetheless, much testing was done, with some of the error checking still left in the code (commented or uncommented). First, I noticed that the getAllPIDparser function could not be called by the findAllPID function because it existed after the findAllfunction rather than before. Thus, I included the function header at the top of the file to allow it to be used by findALLPID(). There was a lot of trial and error testing done when trying to check the pid (if it was a digit and userid). After multiple print statements and use of the debugger (mainly for segmentation faults), I was able to get the code working as intended. There is no else statements included because we only need to account for the cases when the pid is a digit and a user process. The allParser function in this file is almost identical to the parser function from the parser file, so a lot of the checking for errors and usability were similar to what was done there. For example, fprintf() statements, perror() statements, and a for loop for extra arguments was included. Finally, I noticed my code was a bit hard to read in the parser file when the functions from optionProcessor.cpp were also called in the same function. Since the true/false variables for the flags were created as global variables, I realized after some testing that I could call these functions and print the desired output to the terminal in a separate function. I did just this in the getAllPIDparser function. There was no need to check if the PID was valid in this function because it gathers pids directly from the /proc file system, so we know they are correct. I still included printf statements for various checks. 

The next file to examine is the optionProcessor file. The first function created in meant simply for testing purposes as it checks if the inputted pid is a valid pid (that it exists in the proc file system). I kept the print statements in the function (but commented out) to show that I did error checking for this function. The parseStat function was the first function I wrote to parse a file from the proc directory, so this required a lot of trial and error, use of the debugger, and print statements. Some of these print statements are left in the code (but commented out) to show that I did do error checking. I also had to use the debugger to make sure the openParenthesis case was working as intended. This process is the same for the getVMem and getCmdLine functions. However, after more careful consideration, I realized I did not need to use an array to hold the parsed parts of the status file in the getVMem function like I had to for the parseStat and getCMdline funcitons; thus, I instead just used a string and a fscanf function, which made my code simpler and easier to understand. I also had to do some debugging using the debugger and print statements to make sure the cmdline file in proc was being parsed correctly, considering that it contains null characters throughout the file. Some of these print statements are left in the code but commented out. Finally, the isUserId function is one of the functions that caused me the most errors/trouble due to a lot of segmentation fault. The main way of testing/fixing these errors was the debugger, print statments (left in the code commented out for showcasing), and asking others for assistance with the logic of my code. I later learned that the main reason for the errors was the incorrect use of the isdigit function (since I was using it for a string rather than a single character, as the function is intended for). Thus, after using these methods and some trial and error, the code was fixed. 

Finally, to test that the Makefile worked as intended, I first started with the most simple makefile, which would just link and compile the files that existed in my project at that time. This worked on the first attempt, mainly because I did a lot of research into makefiles to make sure I would create it correctly. I later made my MakeFile more complex by adding in flags like CC, WFLAGS, and GDB, as well as putting all my code into a folder called src/*, which makes the readability of the makefile (and my code overall) improve. I also tried doing the complete linking and compilation process (including the compiling of object files), and this worked; however, since this was not necessary, I commented out this code. I also made sure to include the clean statement as requested.

Thus, this was a description of the testing methods used, the errors faced (and how they were handled), and the design of my project.